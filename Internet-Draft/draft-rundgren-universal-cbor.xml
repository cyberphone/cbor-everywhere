<?xml version="1.0" encoding="utf-8"?>

<?xml-model href="rfc7991bis.rnc"?> 

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="info"
  docName="draft-rundgren-universal-cbor-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="3">

  <front>
    <title abbrev="CBOR/U">Universal CBOR</title>

    <seriesInfo name="Internet-Draft" value="draft-rundgren-universal-cbor-00"/>
   
    <author fullname="Anders Rundgren" initials="A." surname="Rundgren" role="editor">
        <organization>Independent</organization>
        <address>
            <postal>
                <city>Montpellier</city>
                <country>France</country>
            </postal>
            <email>anders.rundgren.net@gmail.com</email>
            <uri>https://www.linkedin.com/in/andersrundgren/</uri>
        </address>
    </author>
   
    <date year="2025"/>

    <area>Application</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>CBOR</keyword>
    <keyword>Deterministic</keyword>
    <keyword>Encoding</keyword>
    <keyword>Cryptography</keyword>

    <abstract>
      <t>This document describes a strict subset of CBOR (RFC 8949) that is intended to
          serve as a replacement for JSON and XML.  To foster interoperability, and to
          support cryptographic solutions that also can operate on "raw" (unwrapped)
          CBOR data, deterministic encoding is mandatory.  Although the encoding scheme
          has been proved to be deployable in constrained environments, the primary
          target is rather mainstream platforms like mobile phones and Web servers
      </t>
    </abstract>
 
  </front>

  <middle>
    
    <section>
      <name>Introduction</name>
      <t><xref target="RFC8949"/></t>
      
      <section>
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.</t>
      </section>

    </section>
    
    <section>
      <name>Body [REPLACE]</name>
      <t>Body text [REPLACE]</t>
      
      <ol>
        <li>Ordered list item [REPLACE/DELETE]</li>
      </ol>
      
      <ul>
        <li>Bulleted list item [REPLACE/DELETE]</li>
      </ul>
      
      <dl newline="true">
        <!-- Omit newline="true" if you want each definition to start on the same line as the corresponding term -->
        <dt>First term: [REPLACE/DELETE]</dt>
        <dd>Definition of the first term [REPLACE/DELETE]</dd>
        <dt>Second term: [REPLACE/DELETE]</dt>
        <dd>Definition of the second term [REPLACE/DELETE]</dd>
      </dl>
      
      <table>
        <thead>
        <!-- [REPLACE/DELETE] a table header is optional -->
          <tr><th>Column 1 [REPLACE]</th>
          <th>Column 2 [REPLACE]</th>
          <th>Column 2 [RnhghbhhbhbhhbhbhbhbhbhbbhbhbhbhhnkknknghghghghghghghgEPLACE]</th></tr>
        </thead>
        <tbody>
          <tr><td>Cell [REPLACE]</td>
          <td>Cell [REPLACE]</td>
          <td>Cell [REPLACE]</td></tr>
                    <tr><td>Cell [REPLACE]</td>
          <td>Cell [REPLACE]</td>
          <td>Cell [REPLACE]</td></tr>
        </tbody>
      </table>

      <figure>
        <name>Source [REPLACE]</name>
        <sourcecode name="suggested filename [REPLACE/DELETE]" type="language [REPLACE/DELETE]" markers="true">
          <![CDATA[
source code goes here [REPLACE]
          ]]>
        </sourcecode>
        <!-- [CHECK] markers="true" means that the rendered file will have <CODE BEGINS> and <CODE ENDS> added -->
      </figure>

    </section>   
    
    <section anchor="IANA">
       <name>IANA Considerations</name>
      <t>This memo includes no request to IANA.</t>
    </section>
    
    <section anchor="Security">
       <name>Security Considerations</name>
      <t>All is good :).</t>
    </section>
    
    <!-- NOTE: The Acknowledgements and Contributors sections are at the end of this template -->
  </middle>

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9052.xml"/>
        
      </references>
 
      <references>
        <name>Informative References</name>
       
        <reference anchor="exampleRefMin">
        <!-- [REPLACE/DELETE] Example minimum reference -->
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
            <!-- [CHECK] -->
          </front>
        </reference>

        <reference anchor="CSF" 
  target="https://cyberphone.github.io/javaapi/org/webpki/cbor/doc-files/signatures.html">
          <front>
            <title>CBOR Signature Format (CSF)</title>
            <author initials="A" surname="Rundgren">
              <organization/>
            </author>
            <date year="2025"/>
          </front>
        </reference>       
       
      </references>
    </references>
    
    <section>
      <name>Enveloped Signatures</name>
      <t>This is a <em>non-normative</em> appendix showing how the described
      encoding scheme can be used for supporting enveloped signatures.
      </t>
      <t>The primary advantages with enveloped signatures compared to
      the approach used by COSE <xref target="RFC9052"/> include:</t>
      <ul>
        <li>Keeps the <em>structure</em> of the original (unsigned) data intact,
        by simply making signatures an additional attribute.</li>
        <li>Permits signing CBOR data and associated security
        attributes (aka "headers"), <em>in one go</em>, without
        having to wrap data in CBOR "bstr" objects.</li>
      </ul>
      <t>Although this specification is not "married" to any particular
      signature schema, the example builds on the CBOR Signature Format
      <xref target="CSF"/>.</t>
      <section>
        <name>Unsigned Data</name>
        <t>Imagine you have a CBOR map object like the following
        that you want to sign:</t>
          <sourcecode name="Unsigned Data" type="cbor">
<![CDATA[{
  1: "data",
  2: "more data"
}]]></sourcecode>
      <t>continue to next section...</t>
      </section>
      <section>
        <name>Signature Process</name>
        <t>This section describes the steps required to add an
        enveloped signature to the unsigned data in the previous section.
        To keep things to a minimum, a simple HMAC is used.</t>
        <ol>
        <li>Add an empty CSF container (a CBOR map) to the unsigned data
        using an <em>application-defined</em> label (-1).</li>
        <li>Add a signature algorithm to the
        CSF container using the CSF algorithm label (1).</li>
        <li><em>Optional</em>. Add other signature meta data to the
        CSF container.</li>
        <li><t>Create signature data by calling a signature method with the 
        following arguments:</t>
          <ul>
          <li>the designated signature key.</li>
          <li>the designated signature algorithm.</li>
          <li>the <em>deterministic encoding</em> of the
          current CBOR object in its <em>entirety</em>.</li>
          </ul>
        </li>
        <li>Add the returned signature value to the CSF container
        using the CSF signature label (6).</li>
        </ol>
        <t>The result from final step (if using the COSE "HS256" algorithm
        and the test key), should match the following CBOR object:</t>
        <sourcecode name="Unsigned Data" type="cbor">
<![CDATA[{
  1: "data",
  2: "more data",
  -1: {
    1: 5,
    6: h'4853d7730cc1340682b1748dc346cf627a5e91ce62c67fff15c40257ed2a37a1'
  }
}]]></sourcecode>
      <t>Note that the signature covers the entire object except for
      the CSF signature value and label (6).</t>
      </section>
      <section>
        <name>Validation Process</name>
        <t>In order to validate the enveloped signature created in the
        previous section, perform the following steps:</t>
        <ol>
        <li><t>Fetch a <em>reference</em> to the CSF container using the
        <em>application-defined</em> label (-1).
        Next perform the following operations using the reference:</t>
        <ul>
          <li>Retrieve the signature algorithm using the CSF algorithm label (1).</li>
          <li>Retrieve the signature value using the CSF algorithm label (6).</li>
          <li>Remove the CSF algorithm label (6) and its associated value.</li>
        </ul>
        <t>Now we should have exactly the same CBOR object as we had <em>before</em>
        step #4 in the previous section was performed.
        That is:</t>
                <sourcecode name="Unsigned Data" type="cbor">
<![CDATA[{
  1: "data",
  2: "more data",
  -1: {
    1: 5
  }
}]]></sourcecode>
        </li>
        <li><t>Validate the signature data by calling a signature validation method
        with the following arguments:</t>
          <ul>
          <li>the designated signature key.</li>
          <li>the signature algorithm retrieved in step #1.</li>
          <li>the signature value retrieved in step #1.</li>
          <li>the <em>deterministic encoding</em> of the
          current CBOR object in its <em>entirety</em>.</li>
          </ul>
        </li>
        </ol>
        <t>Note: this is a "bare-bones" validation process, lacking the ruggedness
        of a real-world implementation.</t>
      </section>
      <section>
        <name>Test Key</name>
        <t>The signature example above depends on the following 256-bit
        test key, here provided in hex code:</t>
        <sourcecode name="Unsigned Data" type="any">
<![CDATA[7fdd851a3b9d2dafc5f0d00030e22b9343900cd42ede4948568a4a2ee655291a]]></sourcecode>
      </section>
    </section>

    <section anchor="Acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>None at the time of writing &#x1f638;</t>
    </section>
    
 </back>
</rfc>
